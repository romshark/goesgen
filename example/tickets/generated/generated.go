// Code generated by github.com/romshark/goesgen - DO NOT EDIT.

/* SCHEMA (YAML):events:
  TicketCreated:
    id: id.Ticket
    title: TicketTitle
    description: TicketDescription
    author: id.User
  TicketClosed:
    ticket: id.Ticket
    by: id.User
  TicketCommented:
    id: id.Comment
    ticket: id.Ticket
    message: TicketCommentMessage
    by: id.User
  UserAssignedToTicket:
    user: id.User
    ticket: id.Ticket
    by: id.User
  UserUnassignedFromTicket:
    user: id.User
    ticket: id.Ticket
    by: id.User
  TicketDescriptionChanged:
    ticket: id.Ticket
    newDescription: TicketDescription
    by: id.User
  TicketTitleChanged:
    ticket: id.Ticket
    newTitle: TicketTitle
    by: id.User

projections:
  Ticket:
    states:
      - New
      - InProgress
      - Closed
      - Stalled
    createOn: TicketCreated
    transitions:
      UserAssignedToTicket:
        - New -> New
        - InProgress -> InProgress
        - Stalled -> InProgress
      TicketClosed:
        - New -> Closed
        - InProgress -> Closed
        - Stalled -> Closed
      TicketCommented:
        - InProgress -> InProgress
        - New -> New
        - Stalled -> Stalled
      UserUnassignedFromTicket:
        - InProgress -> InProgress
        - InProgress -> Stalled
      TicketDescriptionChanged:
        - New -> New
        - InProgress -> InProgress
        - Stalled -> Stalled
      TicketTitleChanged:
        - New -> New
        - InProgress -> InProgress
        - Stalled -> Stalled

services:
  Tickets:
    projections:
      - Ticket
    methods:
      GetTicketByID:
        in: id.Ticket
        out: service.tickets.io.GetTicketByIDOut
        type: readonly
      CreateTicket:
        in: service.tickets.io.CreateTicketIn
        out: service.tickets.io.CreateTicketOut
        emits:
          - TicketCreated
      AssignUserToTicket:
        in: service.tickets.io.AssignUserToTicketIn
        emits:
          - UserAssignedToTicket
      CloseTicket:
        in: service.tickets.io.CloseTicketIn
        emits:
          - TicketClosed
      CreateComment:
        in: service.tickets.io.CreateCommentIn
        out: service.tickets.io.CreateCommentOut
        emits:
          - TicketCommented
      UnassignUserFromTicket:
        in: service.tickets.io.UnassignUserFromTicketIn
        emits:
          - UserUnassignedFromTicket
      UpdateTicket:
        in: service.tickets.io.UpdateTicketIn
        emits:
          - TicketDescriptionChanged
          - TicketTitleChanged
*/

package generated

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"reflect"
	"time"

	srctickets "tickets"
	srcticketsid "tickets/id"
	srcticketsserviceticketsio "tickets/service/tickets/io"
)

type Logger interface {
	Printf(format string, values ...interface{})
}

type fallbackLog struct{ w io.Writer }

func (l *fallbackLog) Printf(format string, values ...interface{}) {
	fmt.Fprintf(l.w, format, values...)
}

var defaultLogErr = &fallbackLog{os.Stderr}

/* EVENT TYPES */

// Event represents either of:
//  EventTicketClosed
//  EventTicketCommented
//  EventTicketCreated
//  EventTicketDescriptionChanged
//  EventTicketTitleChanged
//  EventUserAssignedToTicket
//  EventUserUnassignedFromTicket
type Event = interface{}

// EventTicketClosed defines event TicketClosed
type EventTicketClosed struct {
	Ticket srcticketsid.Ticket "json:\"ticket\""

	By srcticketsid.User "json:\"by\""
}

// EventTicketCommented defines event TicketCommented
type EventTicketCommented struct {
	Id srcticketsid.Comment "json:\"id\""

	Ticket srcticketsid.Ticket "json:\"ticket\""

	Message srctickets.TicketCommentMessage "json:\"message\""

	By srcticketsid.User "json:\"by\""
}

// EventTicketCreated defines event TicketCreated
type EventTicketCreated struct {
	Id srcticketsid.Ticket "json:\"id\""

	Title srctickets.TicketTitle "json:\"title\""

	Description srctickets.TicketDescription "json:\"description\""

	Author srcticketsid.User "json:\"author\""
}

// EventTicketDescriptionChanged defines event TicketDescriptionChanged
type EventTicketDescriptionChanged struct {
	Ticket srcticketsid.Ticket "json:\"ticket\""

	NewDescription srctickets.TicketDescription "json:\"newDescription\""

	By srcticketsid.User "json:\"by\""
}

// EventTicketTitleChanged defines event TicketTitleChanged
type EventTicketTitleChanged struct {
	Ticket srcticketsid.Ticket "json:\"ticket\""

	NewTitle srctickets.TicketTitle "json:\"newTitle\""

	By srcticketsid.User "json:\"by\""
}

// EventUserAssignedToTicket defines event UserAssignedToTicket
type EventUserAssignedToTicket struct {
	User srcticketsid.User "json:\"user\""

	Ticket srcticketsid.Ticket "json:\"ticket\""

	By srcticketsid.User "json:\"by\""
}

// EventUserUnassignedFromTicket defines event UserUnassignedFromTicket
type EventUserUnassignedFromTicket struct {
	User srcticketsid.User "json:\"user\""

	Ticket srcticketsid.Ticket "json:\"ticket\""

	By srcticketsid.User "json:\"by\""
}

// GetEventTypeName returns the given event's name.
// Returns "" if the given object is not a valid event.
func GetEventTypeName(e Event) string {
	switch e.(type) {
	case EventTicketClosed:
		return "TicketClosed"
	case EventTicketCommented:
		return "TicketCommented"
	case EventTicketCreated:
		return "TicketCreated"
	case EventTicketDescriptionChanged:
		return "TicketDescriptionChanged"
	case EventTicketTitleChanged:
		return "TicketTitleChanged"
	case EventUserAssignedToTicket:
		return "UserAssignedToTicket"
	case EventUserUnassignedFromTicket:
		return "UserUnassignedFromTicket"
	}
	return ""
}

// CheckEventType returns an error if the given object isn't a valid event,
// otherwise returns nil.
func CheckEventType(e Event) error {
	if GetEventTypeName(e) == "" {
		return UnknownEventTypeErr(fmt.Sprintf(
			"unknown event type %s", reflect.TypeOf(e),
		))
	}
	return nil
}

/* EVENT CODEC */

// EncodeEventJSON encodes one or multiple events to UTF-8 text.
// Multiple events are automatically encoded into a JSON array.
func EncodeEventJSON(e ...Event) ([]byte, error) {
	type E struct {
		TypeName string "json:\"type\""
		Payload  Event  "json:\"payload\""
	}

	if len(e) < 1 {
		return nil, nil
	}
	if len(e) < 2 {
		e := e[0]
		if err := CheckEventType(e); err != nil {
			return nil, err
		}
		return json.Marshal(E{
			TypeName: GetEventTypeName(e),
			Payload:  e,
		})
	}
	m := make([]E, len(e))
	for i, e := range e {
		if err := CheckEventType(e); err != nil {
			return nil, err
		}
		m[i] = E{
			TypeName: GetEventTypeName(e),
			Payload:  e,
		}
	}
	return json.Marshal(m)
}

// DecodeEventJSON decodes an event from UTF-8 text
func DecodeEventJSON(b []byte) (Event, error) {
	var v struct {
		TypeName string          "json:\"type\""
		Payload  json.RawMessage "json:\"payload\""
	}
	d := json.NewDecoder(bytes.NewReader(b))
	d.DisallowUnknownFields()
	if err := d.Decode(&v); err != nil {
		return nil, DecodingEventErr(fmt.Sprintf("decoding event: %s", err))
	}

	switch v.TypeName {
	case "TicketClosed":
		var e EventTicketClosed
		if err := json.Unmarshal(v.Payload, &e); err != nil {
			return nil, DecodingEventErr(fmt.Sprintf(
				"decoding TicketClosed payload: %s",
				err,
			))
		}
		return e, nil
	case "TicketCommented":
		var e EventTicketCommented
		if err := json.Unmarshal(v.Payload, &e); err != nil {
			return nil, DecodingEventErr(fmt.Sprintf(
				"decoding TicketCommented payload: %s",
				err,
			))
		}
		return e, nil
	case "TicketCreated":
		var e EventTicketCreated
		if err := json.Unmarshal(v.Payload, &e); err != nil {
			return nil, DecodingEventErr(fmt.Sprintf(
				"decoding TicketCreated payload: %s",
				err,
			))
		}
		return e, nil
	case "TicketDescriptionChanged":
		var e EventTicketDescriptionChanged
		if err := json.Unmarshal(v.Payload, &e); err != nil {
			return nil, DecodingEventErr(fmt.Sprintf(
				"decoding TicketDescriptionChanged payload: %s",
				err,
			))
		}
		return e, nil
	case "TicketTitleChanged":
		var e EventTicketTitleChanged
		if err := json.Unmarshal(v.Payload, &e); err != nil {
			return nil, DecodingEventErr(fmt.Sprintf(
				"decoding TicketTitleChanged payload: %s",
				err,
			))
		}
		return e, nil
	case "UserAssignedToTicket":
		var e EventUserAssignedToTicket
		if err := json.Unmarshal(v.Payload, &e); err != nil {
			return nil, DecodingEventErr(fmt.Sprintf(
				"decoding UserAssignedToTicket payload: %s",
				err,
			))
		}
		return e, nil
	case "UserUnassignedFromTicket":
		var e EventUserUnassignedFromTicket
		if err := json.Unmarshal(v.Payload, &e); err != nil {
			return nil, DecodingEventErr(fmt.Sprintf(
				"decoding UserUnassignedFromTicket payload: %s",
				err,
			))
		}
		return e, nil
	}
	return nil, UnknownEventTypeErr(fmt.Sprintf(
		"unknown event type %s", v.TypeName,
	))
}

type DecodingEventErr string

func (e DecodingEventErr) Error() string { return string(e) }

type UnknownEventTypeErr string

func (e UnknownEventTypeErr) Error() string { return string(e) }

/* PROJECTIONS */

type ProjectionTicketState string

const (
	ProjectionTicketStateClosed     ProjectionTicketState = "Closed"
	ProjectionTicketStateInProgress ProjectionTicketState = "InProgress"
	ProjectionTicketStateNew        ProjectionTicketState = "New"
	ProjectionTicketStateStalled    ProjectionTicketState = "Stalled"
)

type ProjectionTicket struct {
	state ProjectionTicketState
}

func NewProjectionTicket() ProjectionTicket {
	return ProjectionTicket{
		state: ProjectionTicketStateNew,
	}
}

func (p ProjectionTicket) State() ProjectionTicketState {
	return p.state
}

/* SERVICES */

type EventlogVersion = string

// EventLogger represents an abstract event logger
type EventLogger interface {
	// IsOffsetOutOfBoundErr returns true if the given error
	// is an offset-out-of-bound error
	IsOffsetOutOfBoundErr(error) bool

	// Begin returns the first offset version of the eventlog.
	//
	// WARNING: Begin is expected to be thread-safe.
	Begin(context.Context) (string, error)

	// Scan reads a limited number of events at the given offset version
	// calling the onEvent callback for every received event.
	//
	// WARNING: Scan is expected to be thread-safe.
	Scan(
		ctx context.Context,
		version EventlogVersion,
		limit uint,
		onEvent func(
			offset EventlogVersion,
			tm time.Time,
			payload []byte,
			next EventlogVersion,
		) error,
	) error

	// AppendJSON appends one or multiple new events
	// in JSON format onto the log.
	//
	// WARNING: AppendJSON is expected to be thread-safe.
	AppendJSON(
		ctx context.Context,
		payload []byte,
	) (
		offset EventlogVersion,
		newVersion EventlogVersion,
		tm time.Time,
		err error,
	)

	// TryAppendJSON keeps executing transaction until either cancelled,
	// succeeded (assumed and actual event log versions match)
	// or failed due to an error.
	//
	// WARNING: TryAppendJSON is expected to be thread-safe.
	TryAppendJSON(
		ctx context.Context,
		assumedVersion EventlogVersion,
		transaction func() (events []byte, err error),
		sync func() (EventlogVersion, error),
	) (
		offset EventlogVersion,
		newVersion EventlogVersion,
		tm time.Time,
		err error,
	)
}

// StoreTransactionReadWriter represents an abstract
// read-write (exclusive locking) store transaction handler
type StoreTransactionReadWriter interface {
	Commit()
	Rollback()
}

// StoreTransactionReader represents an abstract
// read only (shared locking) store transaction handler
type StoreTransactionReader interface {
	Complete()
}

// TransactionWriter represents an arbitrary abstract transaction object
// that's supposed to be used for write-only mutations.
// TransactionWriter must not be committed or rolled back!
type TransactionWriter = interface{}

// TransactionReader represents an arbitrary abstract transaction object
// that's supposed to be used for read-only queries.
// TransactionReader must not be committed or rolled back!
type TransactionReader = interface{}

// ServiceTickets projects the following entities:
//  Ticket
// therefore, Tickets subscribes to the following events:
//  TicketClosed
//  TicketCommented
//  UserAssignedToTicket
//  UserUnassignedFromTicket
//  TicketDescriptionChanged
//  TicketTitleChanged
type ServiceTickets struct {
	eventlog EventLogger
	logErr   Logger
	methods  ServiceTicketsMethodCaller
	store    ServiceTicketsStoreHandler
}

// ServiceTicketsStoreHandler represents a store handler implementation
// of the service Tickets
type ServiceTicketsStoreHandler interface {
	// NewTransactionReadWriter creates a new exclusive
	// read-write transaction handler.
	// The returned transaction is passed to implementation methods
	// and will eventually be either committed or rolled back respectively.
	NewTransactionReadWriter() StoreTransactionReadWriter

	// NewTransactionReader creates a new read-only transaction handler.
	// The returned transaction is passed to implementation methods
	// and will eventually be completed.
	NewTransactionReader() StoreTransactionReader

	// ProjectionVersion returns the current projection version.
	// Returns an empty string if the projection wasn't initialized yet.
	// In case an empty string is returned the service will fallback
	// to the begin offset version of the eventlog.
	ProjectionVersion(
		context.Context,
		TransactionReader,
	) (EventlogVersion, error)

	// ApplyEventTicketClosed applies event TicketClosed to the projection.
	// The projection must update its local projection version
	// to the one that is provided.
	ApplyEventTicketClosed(
		context.Context,
		TransactionWriter,
		EventlogVersion,
		time.Time,
		EventTicketClosed,
	) error

	// ApplyEventTicketCommented applies event TicketCommented to the projection.
	// The projection must update its local projection version
	// to the one that is provided.
	ApplyEventTicketCommented(
		context.Context,
		TransactionWriter,
		EventlogVersion,
		time.Time,
		EventTicketCommented,
	) error

	// ApplyEventTicketCreated applies event TicketCreated to the projection.
	// The projection must update its local projection version
	// to the one that is provided.
	ApplyEventTicketCreated(
		context.Context,
		TransactionWriter,
		EventlogVersion,
		time.Time,
		EventTicketCreated,
	) error

	// ApplyEventTicketDescriptionChanged applies event TicketDescriptionChanged to the projection.
	// The projection must update its local projection version
	// to the one that is provided.
	ApplyEventTicketDescriptionChanged(
		context.Context,
		TransactionWriter,
		EventlogVersion,
		time.Time,
		EventTicketDescriptionChanged,
	) error

	// ApplyEventTicketTitleChanged applies event TicketTitleChanged to the projection.
	// The projection must update its local projection version
	// to the one that is provided.
	ApplyEventTicketTitleChanged(
		context.Context,
		TransactionWriter,
		EventlogVersion,
		time.Time,
		EventTicketTitleChanged,
	) error

	// ApplyEventUserAssignedToTicket applies event UserAssignedToTicket to the projection.
	// The projection must update its local projection version
	// to the one that is provided.
	ApplyEventUserAssignedToTicket(
		context.Context,
		TransactionWriter,
		EventlogVersion,
		time.Time,
		EventUserAssignedToTicket,
	) error

	// ApplyEventUserUnassignedFromTicket applies event UserUnassignedFromTicket to the projection.
	// The projection must update its local projection version
	// to the one that is provided.
	ApplyEventUserUnassignedFromTicket(
		context.Context,
		TransactionWriter,
		EventlogVersion,
		time.Time,
		EventUserUnassignedFromTicket,
	) error
}

// ServiceTicketsMethodCaller represents an implementation
// of the service Tickets
type ServiceTicketsMethodCaller interface {

	// AssignUserToTicket represents method Tickets.AssignUserToTicket
	//
	// WARNING: this method is read-only and must not mutate neither
	// the state of the projection nor the projection version!
	// The provided transaction must not be committed or rolled back
	// and shall only be used for queries and mutations.
	AssignUserToTicket(
		context.Context,
		TransactionReader,
		srcticketsserviceticketsio.AssignUserToTicketIn,
	) (
		// No output
		events []Event,
		err error,
	)

	// CloseTicket represents method Tickets.CloseTicket
	//
	// WARNING: this method is read-only and must not mutate neither
	// the state of the projection nor the projection version!
	// The provided transaction must not be committed or rolled back
	// and shall only be used for queries and mutations.
	CloseTicket(
		context.Context,
		TransactionReader,
		srcticketsserviceticketsio.CloseTicketIn,
	) (
		// No output
		events []Event,
		err error,
	)

	// CreateComment represents method Tickets.CreateComment
	//
	// WARNING: this method is read-only and must not mutate neither
	// the state of the projection nor the projection version!
	// The provided transaction must not be committed or rolled back
	// and shall only be used for queries and mutations.
	CreateComment(
		context.Context,
		TransactionReader,
		srcticketsserviceticketsio.CreateCommentIn,
	) (
		output srcticketsserviceticketsio.CreateCommentOut,
		events []Event,
		err error,
	)

	// CreateTicket represents method Tickets.CreateTicket
	//
	// WARNING: this method is read-only and must not mutate neither
	// the state of the projection nor the projection version!
	// The provided transaction must not be committed or rolled back
	// and shall only be used for queries and mutations.
	CreateTicket(
		context.Context,
		TransactionReader,
		srcticketsserviceticketsio.CreateTicketIn,
	) (
		output srcticketsserviceticketsio.CreateTicketOut,
		events []Event,
		err error,
	)

	// GetTicketByID represents method Tickets.GetTicketByID
	//
	// WARNING: this method is read-only and must not mutate neither
	// the state of the projection nor the projection version!
	// The provided transaction must not be committed or rolled back
	// and shall only be used for queries and mutations.
	GetTicketByID(
		context.Context,
		TransactionReader,
		srcticketsid.Ticket,
	) (
		output srcticketsserviceticketsio.GetTicketByIDOut,
		// No events
		err error,
	)

	// UnassignUserFromTicket represents method Tickets.UnassignUserFromTicket
	//
	// WARNING: this method is read-only and must not mutate neither
	// the state of the projection nor the projection version!
	// The provided transaction must not be committed or rolled back
	// and shall only be used for queries and mutations.
	UnassignUserFromTicket(
		context.Context,
		TransactionReader,
		srcticketsserviceticketsio.UnassignUserFromTicketIn,
	) (
		// No output
		events []Event,
		err error,
	)

	// UpdateTicket represents method Tickets.UpdateTicket
	//
	// WARNING: this method is read-only and must not mutate neither
	// the state of the projection nor the projection version!
	// The provided transaction must not be committed or rolled back
	// and shall only be used for queries and mutations.
	UpdateTicket(
		context.Context,
		TransactionReader,
		srcticketsserviceticketsio.UpdateTicketIn,
	) (
		// No output
		events []Event,
		err error,
	)
}

// NewServiceTickets creates a new instance of the Tickets service.
func NewServiceTickets(
	methodCaller ServiceTicketsMethodCaller,
	storeHandler ServiceTicketsStoreHandler,
	eventLogger EventLogger,
	errorLogger Logger,
) *ServiceTickets {
	if methodCaller == nil {
		panic("methodCaller is nil in NewServiceTickets")
	}
	if storeHandler == nil {
		panic("storeHandler is nil in NewServiceTickets")
	}
	if eventLogger == nil {
		panic("eventLogger is nil in NewServiceTickets")
	}
	if errorLogger == nil {
		errorLogger = defaultLogErr
	}
	return &ServiceTickets{
		methods:  methodCaller,
		store:    storeHandler,
		eventlog: eventLogger,
		logErr:   errorLogger,
	}
}

// ProjectionVersion returns the current projection version
func (s *ServiceTickets) ProjectionVersion(ctx context.Context) (
	EventlogVersion,
	error,
) {
	txn := s.store.NewTransactionReader()
	defer txn.Complete()

	return s.projectionVersion(ctx, txn)
}

func (s *ServiceTickets) projectionVersion(
	ctx context.Context,
	txn TransactionReader,
) (
	EventlogVersion,
	error,
) {
	v, err := s.store.ProjectionVersion(ctx, txn)
	if err != nil {
		return "", fmt.Errorf("reading projection version: %w", err)
	}
	if v != "" {
		return v, nil
	}

	// Fallback to the beginning of the eventlog
	v, err = s.eventlog.Begin(ctx)
	if err != nil {
		return "", fmt.Errorf("reading begin offset version: %w", err)
	}
	return v, nil
}

// Sync synchronizes service Tickets against the eventlog.
// Sync will scan events until it reaches the tip of the event log and
// always return the latest version of the event log it managed to reach,
// unless the returned error is not equal context.Canceled or
// context.DeadlineExceeded and didn't pass isErrAcceptable (if not nil).
func (s *ServiceTickets) Sync(
	ctx context.Context,
	isErrAcceptable func(error) bool,
) (
	latestVersion EventlogVersion,
	err error,
) {
	txn := s.store.NewTransactionReadWriter()
	defer func() {
		if err == nil ||
			errors.Is(err, context.Canceled) ||
			errors.Is(err, context.DeadlineExceeded) ||
			(isErrAcceptable != nil && isErrAcceptable(err)) {
			txn.Commit()
		} else {
			txn.Rollback()
		}
	}()

	return s.sync(ctx, txn)
}

func (s *ServiceTickets) sync(
	ctx context.Context,
	trx TransactionWriter,
) (
	latestVersion EventlogVersion,
	err error,
) {
	initialVersion, err := s.projectionVersion(ctx, trx)
	if err != nil {
		return "", err
	}

	if err := s.eventlog.Scan(
		ctx,
		initialVersion,
		0, // No limit
		func(
			offset EventlogVersion,
			tm time.Time,
			payload []byte,
			next EventlogVersion,
		) error {
			ev, err := DecodeEventJSON(payload)
			if err != nil {
				return err
			}
			switch v := ev.(type) {
			case EventTicketClosed:
				if err := s.store.ApplyEventTicketClosed(
					ctx, trx, next, tm, v,
				); err != nil {
					return err
				}
				latestVersion = next
			case EventTicketCommented:
				if err := s.store.ApplyEventTicketCommented(
					ctx, trx, next, tm, v,
				); err != nil {
					return err
				}
				latestVersion = next
			case EventTicketCreated:
				if err := s.store.ApplyEventTicketCreated(
					ctx, trx, next, tm, v,
				); err != nil {
					return err
				}
				latestVersion = next
			case EventTicketDescriptionChanged:
				if err := s.store.ApplyEventTicketDescriptionChanged(
					ctx, trx, next, tm, v,
				); err != nil {
					return err
				}
				latestVersion = next
			case EventTicketTitleChanged:
				if err := s.store.ApplyEventTicketTitleChanged(
					ctx, trx, next, tm, v,
				); err != nil {
					return err
				}
				latestVersion = next
			case EventUserAssignedToTicket:
				if err := s.store.ApplyEventUserAssignedToTicket(
					ctx, trx, next, tm, v,
				); err != nil {
					return err
				}
				latestVersion = next
			case EventUserUnassignedFromTicket:
				if err := s.store.ApplyEventUserUnassignedFromTicket(
					ctx, trx, next, tm, v,
				); err != nil {
					return err
				}
				latestVersion = next
			}
			return nil
		},
	); err != nil {
		if s.eventlog.IsOffsetOutOfBoundErr(err) {
			return latestVersion, nil
		}
		return "", err
	}
	return latestVersion, nil
}

func (s *ServiceTickets) AssignUserToTicket(
	ctx context.Context,
	input srcticketsserviceticketsio.AssignUserToTicketIn,
) (
	// No output
	events []Event,
	eventsPushTime time.Time,
	err error,
) {
	txn := s.store.NewTransactionReadWriter()
	defer func() {
		if err == nil ||
			errors.Is(err, context.Canceled) ||
			errors.Is(err, context.DeadlineExceeded) {
			txn.Commit()
		} else {
			txn.Rollback()
		}
	}()

	var eventsJSON []byte

	defer func() {
		if err != nil {
			// No output to reset
			events = nil
			eventsJSON = nil
			eventsPushTime = time.Time{}
		}
	}()

	exec := func() (ok bool) {
		events, err = s.methods.AssignUserToTicket(ctx, txn, input)
		if err != nil {
			return false
		}
		for i, e := range events {
			if err = CheckEventType(e); err != nil {
				err = fmt.Errorf("checking returned event (%d): %w", i, err)
				return false
			}
			switch e.(type) {
			case EventUserAssignedToTicket:
			default:
				panic(fmt.Errorf(
					"method Tickets.AssignUserToTicket is not allowed to emit event %s",
					reflect.TypeOf(e),
				))
			}
		}
		if eventsJSON, err = EncodeEventJSON(events...); err != nil {
			return false
		}
		return true
	}

	var currentVersion EventlogVersion
	currentVersion, err = s.projectionVersion(ctx, txn)
	if err != nil {
		return
	}

	_, _, eventsPushTime, err = s.eventlog.TryAppendJSON(
		ctx,
		currentVersion,
		func() ([]byte, error) {
			if !exec() {
				return nil, err
			}
			return eventsJSON, nil
		},
		func() (EventlogVersion, error) { return s.sync(ctx, txn) },
	)

	return
}

func (s *ServiceTickets) CloseTicket(
	ctx context.Context,
	input srcticketsserviceticketsio.CloseTicketIn,
) (
	// No output
	events []Event,
	eventsPushTime time.Time,
	err error,
) {
	txn := s.store.NewTransactionReadWriter()
	defer func() {
		if err == nil ||
			errors.Is(err, context.Canceled) ||
			errors.Is(err, context.DeadlineExceeded) {
			txn.Commit()
		} else {
			txn.Rollback()
		}
	}()

	var eventsJSON []byte

	defer func() {
		if err != nil {
			// No output to reset
			events = nil
			eventsJSON = nil
			eventsPushTime = time.Time{}
		}
	}()

	exec := func() (ok bool) {
		events, err = s.methods.CloseTicket(ctx, txn, input)
		if err != nil {
			return false
		}
		for i, e := range events {
			if err = CheckEventType(e); err != nil {
				err = fmt.Errorf("checking returned event (%d): %w", i, err)
				return false
			}
			switch e.(type) {
			case EventTicketClosed:
			default:
				panic(fmt.Errorf(
					"method Tickets.CloseTicket is not allowed to emit event %s",
					reflect.TypeOf(e),
				))
			}
		}
		if eventsJSON, err = EncodeEventJSON(events...); err != nil {
			return false
		}
		return true
	}

	var currentVersion EventlogVersion
	currentVersion, err = s.projectionVersion(ctx, txn)
	if err != nil {
		return
	}

	_, _, eventsPushTime, err = s.eventlog.TryAppendJSON(
		ctx,
		currentVersion,
		func() ([]byte, error) {
			if !exec() {
				return nil, err
			}
			return eventsJSON, nil
		},
		func() (EventlogVersion, error) { return s.sync(ctx, txn) },
	)

	return
}

func (s *ServiceTickets) CreateComment(
	ctx context.Context,
	input srcticketsserviceticketsio.CreateCommentIn,
) (
	output srcticketsserviceticketsio.CreateCommentOut,
	events []Event,
	eventsPushTime time.Time,
	err error,
) {
	txn := s.store.NewTransactionReadWriter()
	defer func() {
		if err == nil ||
			errors.Is(err, context.Canceled) ||
			errors.Is(err, context.DeadlineExceeded) {
			txn.Commit()
		} else {
			txn.Rollback()
		}
	}()

	var outZero srcticketsserviceticketsio.CreateCommentOut
	var eventsJSON []byte

	defer func() {
		if err != nil {
			output = outZero
			events = nil
			eventsJSON = nil
			eventsPushTime = time.Time{}
		}
	}()

	exec := func() (ok bool) {
		output, events, err = s.methods.CreateComment(ctx, txn, input)
		if err != nil {
			return false
		}
		for i, e := range events {
			if err = CheckEventType(e); err != nil {
				err = fmt.Errorf("checking returned event (%d): %w", i, err)
				return false
			}
			switch e.(type) {
			case EventTicketCommented:
			default:
				panic(fmt.Errorf(
					"method Tickets.CreateComment is not allowed to emit event %s",
					reflect.TypeOf(e),
				))
			}
		}
		if eventsJSON, err = EncodeEventJSON(events...); err != nil {
			return false
		}
		return true
	}

	var currentVersion EventlogVersion
	currentVersion, err = s.projectionVersion(ctx, txn)
	if err != nil {
		return
	}

	_, _, eventsPushTime, err = s.eventlog.TryAppendJSON(
		ctx,
		currentVersion,
		func() ([]byte, error) {
			if !exec() {
				return nil, err
			}
			return eventsJSON, nil
		},
		func() (EventlogVersion, error) { return s.sync(ctx, txn) },
	)

	return
}

func (s *ServiceTickets) CreateTicket(
	ctx context.Context,
	input srcticketsserviceticketsio.CreateTicketIn,
) (
	output srcticketsserviceticketsio.CreateTicketOut,
	events []Event,
	eventsPushTime time.Time,
	err error,
) {
	txn := s.store.NewTransactionReadWriter()
	defer func() {
		if err == nil ||
			errors.Is(err, context.Canceled) ||
			errors.Is(err, context.DeadlineExceeded) {
			txn.Commit()
		} else {
			txn.Rollback()
		}
	}()

	var outZero srcticketsserviceticketsio.CreateTicketOut
	var eventsJSON []byte

	defer func() {
		if err != nil {
			output = outZero
			events = nil
			eventsJSON = nil
			eventsPushTime = time.Time{}
		}
	}()

	exec := func() (ok bool) {
		output, events, err = s.methods.CreateTicket(ctx, txn, input)
		if err != nil {
			return false
		}
		for i, e := range events {
			if err = CheckEventType(e); err != nil {
				err = fmt.Errorf("checking returned event (%d): %w", i, err)
				return false
			}
			switch e.(type) {
			case EventTicketCreated:
			default:
				panic(fmt.Errorf(
					"method Tickets.CreateTicket is not allowed to emit event %s",
					reflect.TypeOf(e),
				))
			}
		}
		if eventsJSON, err = EncodeEventJSON(events...); err != nil {
			return false
		}
		return true
	}

	var currentVersion EventlogVersion
	currentVersion, err = s.projectionVersion(ctx, txn)
	if err != nil {
		return
	}

	_, _, eventsPushTime, err = s.eventlog.TryAppendJSON(
		ctx,
		currentVersion,
		func() ([]byte, error) {
			if !exec() {
				return nil, err
			}
			return eventsJSON, nil
		},
		func() (EventlogVersion, error) { return s.sync(ctx, txn) },
	)

	return
}

func (s *ServiceTickets) GetTicketByID(
	ctx context.Context,
	input srcticketsid.Ticket,
) (
	output srcticketsserviceticketsio.GetTicketByIDOut,
	// No events
	err error,
) {
	txn := s.store.NewTransactionReader()
	defer txn.Complete()

	var outZero srcticketsserviceticketsio.GetTicketByIDOut

	defer func() {
		if err != nil {
			output = outZero
			// No events to reset
		}
	}()

	exec := func() (ok bool) {
		output, err = s.methods.GetTicketByID(ctx, txn, input)
		if err != nil {
			return false
		}

		return true
	}

	exec()

	return
}

func (s *ServiceTickets) UnassignUserFromTicket(
	ctx context.Context,
	input srcticketsserviceticketsio.UnassignUserFromTicketIn,
) (
	// No output
	events []Event,
	eventsPushTime time.Time,
	err error,
) {
	txn := s.store.NewTransactionReadWriter()
	defer func() {
		if err == nil ||
			errors.Is(err, context.Canceled) ||
			errors.Is(err, context.DeadlineExceeded) {
			txn.Commit()
		} else {
			txn.Rollback()
		}
	}()

	var eventsJSON []byte

	defer func() {
		if err != nil {
			// No output to reset
			events = nil
			eventsJSON = nil
			eventsPushTime = time.Time{}
		}
	}()

	exec := func() (ok bool) {
		events, err = s.methods.UnassignUserFromTicket(ctx, txn, input)
		if err != nil {
			return false
		}
		for i, e := range events {
			if err = CheckEventType(e); err != nil {
				err = fmt.Errorf("checking returned event (%d): %w", i, err)
				return false
			}
			switch e.(type) {
			case EventUserUnassignedFromTicket:
			default:
				panic(fmt.Errorf(
					"method Tickets.UnassignUserFromTicket is not allowed to emit event %s",
					reflect.TypeOf(e),
				))
			}
		}
		if eventsJSON, err = EncodeEventJSON(events...); err != nil {
			return false
		}
		return true
	}

	var currentVersion EventlogVersion
	currentVersion, err = s.projectionVersion(ctx, txn)
	if err != nil {
		return
	}

	_, _, eventsPushTime, err = s.eventlog.TryAppendJSON(
		ctx,
		currentVersion,
		func() ([]byte, error) {
			if !exec() {
				return nil, err
			}
			return eventsJSON, nil
		},
		func() (EventlogVersion, error) { return s.sync(ctx, txn) },
	)

	return
}

func (s *ServiceTickets) UpdateTicket(
	ctx context.Context,
	input srcticketsserviceticketsio.UpdateTicketIn,
) (
	// No output
	events []Event,
	eventsPushTime time.Time,
	err error,
) {
	txn := s.store.NewTransactionReadWriter()
	defer func() {
		if err == nil ||
			errors.Is(err, context.Canceled) ||
			errors.Is(err, context.DeadlineExceeded) {
			txn.Commit()
		} else {
			txn.Rollback()
		}
	}()

	var eventsJSON []byte

	defer func() {
		if err != nil {
			// No output to reset
			events = nil
			eventsJSON = nil
			eventsPushTime = time.Time{}
		}
	}()

	exec := func() (ok bool) {
		events, err = s.methods.UpdateTicket(ctx, txn, input)
		if err != nil {
			return false
		}
		for i, e := range events {
			if err = CheckEventType(e); err != nil {
				err = fmt.Errorf("checking returned event (%d): %w", i, err)
				return false
			}
			switch e.(type) {
			case EventTicketDescriptionChanged:
			case EventTicketTitleChanged:
			default:
				panic(fmt.Errorf(
					"method Tickets.UpdateTicket is not allowed to emit event %s",
					reflect.TypeOf(e),
				))
			}
		}
		if eventsJSON, err = EncodeEventJSON(events...); err != nil {
			return false
		}
		return true
	}

	var currentVersion EventlogVersion
	currentVersion, err = s.projectionVersion(ctx, txn)
	if err != nil {
		return
	}

	_, _, eventsPushTime, err = s.eventlog.TryAppendJSON(
		ctx,
		currentVersion,
		func() ([]byte, error) {
			if !exec() {
				return nil, err
			}
			return eventsJSON, nil
		},
		func() (EventlogVersion, error) { return s.sync(ctx, txn) },
	)

	return
}
